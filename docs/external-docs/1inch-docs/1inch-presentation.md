# Video Transcript (Generated by Whisper)

**[00:00]** Nice. Welcome to all the real people to all of the AI chat bots. This stream is recorded,

**[00:18]** and we will have the link for you on YouTube live after as well. All right. And welcome to this

**[00:28]** 30 minute workshop. I'll head on one inch cross chain swaps with Tannermore. So Tanner, I'll let you take

**[00:33]** it from here and I'll be in the background if you need anything. Okay. Sounds good. Hi everybody. Yes.

**[00:39]** So this presentation is one inch cross chain swaps fusion plus and my name is Tannermore. I am

**[00:45]** a developer relations engineer at one inch. So the presentation today, we're going to start with

**[00:53]** talking briefly about our classic swap, which is our AMM and P&M aggregation, what we were originally

**[00:58]** famous for. We will then move on to one inch fusion, which was our implementation of intent based

**[01:04]** swaps. We will then talk about one inch fusion plus, which was built on intent based swaps to

**[01:09]** enable cross chain swaps. And then finally, we will talk about how to actually build for the

**[01:14]** cross chain swap bounty for this hack of a. So let's jump right in with swapping with one inch. So here

**[01:23]** are all of the chains that one inch currently supports today. We have the Ethereum L1. We have side chains.

**[01:29]** We have some other EVM L1s. We have L2s. And we are going to keep growing this over time.

**[01:38]** There is one non-new VM implementation we have done so far and this is fusion swaps on Solana.

**[01:45]** So this was our first step into non-evm stuff. And we are going to continue expanding that,

**[01:51]** which is part of the reason we are having this hack upon right now. So let's start with classic swap.

**[01:58]** So classic swap, which is what many of you probably know us for. This is what we are most famous for.

**[02:04]** This source is swap liquidity from all popular protocols. It combines these protocols to

**[02:09]** optimize the swap output and executes all swaps in a single transaction. So all on chain aggregation.

**[02:16]** So if we look at a quick example, we say a user wants to go from USDC to die.

**[02:21]** A lot of them will probably just go through Uniswap because that's what everybody is.

**[02:25]** Aware of and it will have low price impact, low slippage, all of that. But they could also go through

**[02:30]** the one-inch aggregation router, which with smaller amounts would probably still go through Uniswap.

**[02:35]** But if you get too much bigger amounts of USDC being swapped to die, or if you do other pairs

**[02:40]** that are less common, then you really start to see the benefits of the aggregation router.

**[02:44]** We might split your trade partially through Dodo. We might do an intermediary trade through

**[02:49]** curve to USDC before finding something that sushi swap to convert it to die. So the less common

**[02:56]** pairs you do and the higher volumes you do, the more you really see the benefit of using an

**[03:01]** aggregator instead of going directly through a single decks.

**[03:06]** Even in cases where we go directly to Uniswap from a router, there are still benefits to

**[03:11]** using our router because we actually can do it for less gas. So the same swap going through the same

**[03:17]** decks, at least in the example here with Uniswap V3, you would actually still save some gas

**[03:22]** on the transaction. Now this isn't as relevant anymore because gas prices are quite cheap,

**[03:26]** but there was a time where this was incredibly relevant and this would have been probably like a

**[03:30]** $10 difference in your swap. Okay, so that's a quick explanation of the classic swap.

**[03:37]** And now we can jump into one-inch fusion, which is intent-based swaps, which is where we really

**[03:41]** start to get into the hackathon work that we're doing today. So fusion plus is not cross-chain

**[03:45]** swaps. It is our intent-based same-chain swaps. So in this system what we do is we have a user

**[03:53]** submit a swap request with a signature. A Dutch auction is created for the swap. Resolve

**[04:00]** as in our system, a synchronously compete to fill it. Users are protected from MEV by design,

**[04:07]** which means they don't lose value of their trade to external factors that are out of their control.

**[04:13]** And gas-less transactions for users, which is something that is not true in our classic swap,

**[04:18]** because in this system somebody else is feeling the swap for you. So there were a lot of terms

**[04:24]** that I just explained in that overview slide. So let's jump into some of them. You might be asking

**[04:29]** what is a fusion Dutch auction or more broadly what is a Dutch auction? And in a normal auction,

**[04:34]** you start at some low price and you slowly work up in price until there's only one better

**[04:39]** left and that's the final price. But in a Dutch auction you actually started a slight

**[04:44]** be high price compared to what you think the value of something is and then you slowly work down

**[04:48]** until one person says, okay, this is the price I'm interested in and then it ends.

**[04:54]** The other term that you might not be familiar with is what is a resolver and these are the counter

**[04:58]** parties in our intent-based system that are watching these Dutch auctions and watching these

**[05:02]** swap requests and actually filling the swap for the user. So here is a very simplified diagram of a

**[05:08]** Dutch auction. You can see that on the x-axis is time and on the y-axis is rate and that top left

**[05:15]** point is the max price for the tokens. You can think of this as just at market rate or slightly above

**[05:20]** market rate and then slowly over time that rate for the token swap will go down until one

**[05:25]** resolver jumps in and says, hey, this is something I'm interested in. This is the swap that I will

**[05:29]** do for the user. So let's go through a diagram of what this actually looks like from the user's

**[05:34]** perspective and internally. So a user comes in and says, hey, I would like to swap 50 USD for

**[05:39]** die in the fusion system. The fusion system will estimate that they'll get around 50 die back since

**[05:44]** this is stablecoins. The user will say, okay, it looks good, let's sign the transaction and that will

**[05:49]** be sent off to the one in JPI. The one in JPI will then say, okay, we are starting a fusion auction

**[05:56]** for 50 USD, being swap the die and they send this off to all of the resolvers in the fusion system.

**[06:03]** Now each block, this will slowly go down in price. So at the beginning, most resolvers will probably

**[06:09]** pass, but after a couple blocks, once it gets to either exactly at market rate or slightly below

**[06:13]** market rate, some of the resolvers will jump and say, hey, this is something I'm interested in

**[06:17]** executing. So I will try to take this swap for the user. If in the same block multiple resolvers,

**[06:22]** try to execute the trade for the user, whoever pays the most gas will win and whoever does not,

**[06:28]** we'll just get it over to error and they will not actually be able to fill a swap for the user.

**[06:32]** Now partial fills are allowed. So if both of the resolvers together are swapping less than the total

**[06:38]** amount of the swap, they will both be fine to go in the same block and the auction will continue

**[06:43]** until the full 50 USD, see has been swapped for die. So here is a chart of a real swap that

**[06:51]** happened in the fusion system. This was for 3700 ether to USDT. The slanted line with all the dots on it

**[06:58]** is the live price during the auction and each of those dots is a point at which a resolver

**[07:03]** did a partial fill. So we started at slightly above market rate, which is the perfectly flat dotted line,

**[07:08]** just slightly above market rate and then across the next five minutes, there were 17 partial

**[07:14]** fills that had the entire swap complete all at slightly above market rate. So this is something

**[07:19]** that would be completely impossible with normal decks because this isn't just zero slippage in price

**[07:24]** impact, this is actually getting slightly above market rate. So this really shows the power of

**[07:28]** intent based swapping and likely why most swaps in the future will gravitate towards this over

**[07:32]** doing traditional on chain swaps through through Daxus. So one question you guys might be having is

**[07:39]** where these resolvers actually get their liquidity for these swaps and that's kind of the

**[07:43]** beauty of the system is it's really up to the resolver. They just have to follow the rules of the

**[07:49]** smart contracts that say what the current rate is and the rest is up to them. So maybe they get

**[07:54]** some of their liquidity from a centralized exchange, maybe they're a family office and just

**[07:59]** have a lot of personal funds that they used to facilitate these swaps. Maybe they found cool arbitrage

**[08:04]** opportunities on various deckses or maybe they actually do cross chain arbitrage as well. All of

**[08:11]** these things are possible. It's just as long as the resolvers fall the swap rates, then we don't

**[08:16]** really have to worry about telling them where to get this liquidity they just have to get creative.

**[08:21]** Okay, that brings us on to Fusion Plus. This is built on top of the Fusion System but now moves

**[08:29]** into the next kind of iteration of the tech stack which is supporting cross chain swaps.

**[08:35]** Okay, so when we were building Fusion Plus or when we were building cross chain swaps,

**[08:40]** we asked ourselves a couple of questions. What actually matters for the user? We know they want

**[08:45]** good swap rates because in the end that's what people really care about is hey how much money

**[08:49]** I'm going to lose when I'm doing a swap between two tokens and two chains. We knew that

**[08:53]** simply UX was really important because new users don't want big complicated UIs. They want something

**[08:58]** that is fairly straightforward and easy to use. And the last one that we thought was very important

**[09:02]** was trustlessness because it's very easy to build these like bridges and cross chain swaps if you

**[09:07]** have trusted systems. But if you make something that truly makes it where the user does not have

**[09:11]** to worry that they're trusting somebody else, that's when you get really powerful systems that

**[09:17]** scale and people will tell about their share with their friends. And the technology that we

**[09:22]** decided to center around is called hash time lock contracts. So simply put hash time lock contracts

**[09:30]** are just a smart contract that holds funds and it requires some secret S to unlock those funds.

**[09:38]** And it will expire after a set of amount of time. So within a block of time you have to provide

**[09:44]** the secret to the contract to get the funds and if that block of time passes and the secret is

**[09:48]** not provided then the only thing that can happen at that point is the funds go back to the original

**[09:53]** source. So let's go through a kind of a diagram to show that. So user has some secret S. Only they

**[10:00]** know the secret S they generated they keep it very close close to themselves and they don't publish

**[10:04]** anywhere. And then they hash the secret S to get some deterministic value and they send this into

**[10:12]** the creation of a smart contract. In this contract they will also put like some sort of value let's

**[10:18]** just say ether and if someone else is talking to this contract and they say hey I want to pull the

**[10:22]** ether out of this contract that will fail they can't actually get this money out of the contract.

**[10:27]** But if the user gives their secret to this person that person can now pull the funds out of the

**[10:33]** contract. So this at a very high level is the idea behind hash time lock contracts.

**[10:38]** So let's go through a diagram. It's going to look very similar to fusion because it was built

**[10:42]** on top of fusion hence the fusion plus. A user says hey I would like to swap 50 USD C on Ethereum

**[10:48]** for a die on base. Again our system will say okay you're going to get around 50 die when this is

**[10:53]** all over. The user signs this transaction and they send it off to the one in JPI.

**[11:00]** The one in JPI starts Dutch auction says hey this user is swapping from Ethereum to base here's the

**[11:05]** amount and just like before all the resolvers are going to be looking at this and watching the

**[11:09]** prices slowly take down to some rate that they're interested in and just like before they will

**[11:13]** compete to fill it. So let's say resolver 2 in this case has claimed the SWAT for the user.

**[11:25]** Now I can get into the actual specifics of the fusion plus implementation. So the first thing

**[11:29]** they're going to do is they're going to create an escrow contract on Ethereum and they're going to

**[11:33]** deposit something we call the safety deposit and this is a financial incentivization for somebody

**[11:41]** to make sure that no matter what happens these funds either go to where they're supposed to go

**[11:45]** or they go back to the original source. So if resolver 2 doesn't actually make this thing end

**[11:52]** and transaction completely end somebody else can come in finish the transaction for them and they'll

**[11:56]** earn that safety deposit. So it's a mechanism to make sure that funds do not get stuck. So resolver 2

**[12:02]** sends a safety deposit creates escrow contract in Ethereum. They then also make the escrow

**[12:07]** contract on base again sending in that safety deposit. They use the permission that the user

**[12:13]** granted the one inch router to move the funds from the user's wallet to the escrow contract.

**[12:18]** So resolver 2 doesn't have control here but they can call a function on our aggregator contract

**[12:23]** or our resolver contract which will then move those funds for the user into this escrow contract.

**[12:29]** The resolver will then put their own funds into the escrow contract on the destination chain

**[12:34]** in this case die and now the stage is set. The user's funds have been moved to the escrow

**[12:39]** contract on the search chain and the resolvers funds have been moved to the escrow contract on the

**[12:43]** destination chain. And here is where the relayer service comes in. So this is a service that is

**[12:49]** watching the escrow on the source chain. They're watching the escrow on the destination chain.

**[12:53]** Oops. What a way that happened. And they are making sure that the funds come through on both

**[13:01]** of them and of the right amounts. And after it after it sees that the funds are on both contracts

**[13:08]** on both chains it waits for some sort of finality period to make sure that they're actually on

**[13:12]** there and there's going to be no weird re-orders that make the funds not actually exist. And then

**[13:18]** it says okay everything is good to go. The user can now share the secret so that the resolver

**[13:22]** can unlock the funds. So relayer tells the user users shares the secret with the relayer.

**[13:27]** And now the relayer is going to share that secret with the resolver too so he can complete the

**[13:31]** transaction in the end. Again, this is an important piece of the system where the secret will

**[13:38]** also be shared with every other resolver to make sure that if resolver 2 does not actually

**[13:42]** complete the slot for the user. One of the other resolvers in the system can do that on behalf

**[13:48]** of resolver 2 and user and they'll earn that safety deposit and complete the swap. So this

**[13:52]** kind of all comes down to a system where you don't have to rely on resolver 2 to make the

**[13:56]** final result happen. It can be anybody in the system but resolver 2 will get a small period of

**[14:00]** time where they can do it and earn that safety deposit back since they were the original depositor.

**[14:06]** So this obviously is not just limited to the EVM because that's why you are all here.

**[14:12]** So let's actually talk about how you're going to integrate this into your project using an

**[14:16]** non-EVM chain. So your primary goal with this hackathon is to manage these hash time-let

**[14:24]** contracts and the communication between an EVM chain and your non-EVM chain. For the hackathon,

**[14:29]** a CLI in test-it is totally okay. So if everything's on the command line and you're just using

**[14:34]** test-it that's totally fine for kind of your first version because we're just trying to get

**[14:38]** something that is actually valid and working so that you can be eligible for the boundaries.

**[14:42]** You need to properly handle the hash lock logic on the ESPRO contracts. You need to properly handle

**[14:47]** the expiration and reverts on the ESPRO contracts and your swaps must be bi-directional. So it

**[14:53]** needs to start on EVM chain and go to your non-EVM chain and needs to start on the non-EVM chain

**[14:58]** and go to your EVM chain. So both directions need to be functional. So kind of at the smart

**[15:04]** contract level, you need to use the 1-inch ESPRO fact 3 to deploy a 1-inch ESPRO contract.

**[15:11]** You need to implement an ESPRO contract on whatever non-EVM chain you are interested in

**[15:17]** and you need to handle all the cross chain orchestration between these two chains.

**[15:26]** So that is kind of the base case, right? But there's a lot of ways you can actually improve your

**[15:30]** score and increase your rank in whatever chain you decide to build on. The first is to actually

**[15:35]** make a UI, make it look really pretty, that'd be awesome, enable partial fills. We didn't

**[15:40]** talk about this much now, but you can do more than just a single secret with the ESPRO

**[15:44]** contracts. You can actually do multiple secrets with the ESPRO contract so that there can be

**[15:49]** partial fills for multiple resolvers. You can implement your relayer and resolver in the non-EVM

**[15:55]** chain and try to imitate our design the best you can so that it looks more cohesive and works more

**[16:01]** fluidly. And you can also make this work on mainnet on Ethereum or one of the L2s and the mainnet

**[16:08]** on whatever non-EVM you choose. So these are always to improve your score and to do better in the

**[16:13]** hackathon. One important note, you should not be posting these orders to our official

**[16:21]** rest APIs. The rest APIs are how you actually do fusion swaps with our live set of resolvers,

**[16:27]** but this is not going to work. And the reason for that is the resolvers in our system are

**[16:31]** whitelisted, they are KYC, it's a very controlled environment for these people who are actually

**[16:36]** being in your counter parties. So for the hackathon, you're not jumping into the live system,

**[16:40]** you're going to be working just at the smart contract level and filling things kind of on your own

**[16:44]** without actually being broadcast to everybody and being live in the system. It will still be

**[16:48]** official fusion orders. It just will not be broadcast to the same way. It would be if you were a

**[16:52]** wireless resolver in our system. Okay, last question is we kind of have a good overview of what

**[16:58]** fusion pluses, we have a good overview of what you need to do for the hackathon. So actually,

**[17:02]** where do you start? And thankfully, there is a repo on our GitHub called cross chain resolver

**[17:07]** example that I'll be a link at the end of the presentation. So don't worry about writing this down

**[17:11]** right now. What this repo does is it is written in TypeScript and it will simulate a fusion plus

**[17:18]** swap between Ethereum and BNB. It has all of the information you need for the EVM side of your project.

**[17:25]** So this is going to be a local fork of Ethereum doing a swap with a local fork of the BNB chain,

**[17:32]** and it will give you information about how our smart contracts work had a call these smart contracts,

**[17:36]** how to deposit your safety deposit. It'll have all of that information. All you need to do is

**[17:41]** fall this really simple read me a couple install commands. You run PNPM test and it will show you

**[17:47]** everything you need to see. I think the file is main.spec.ts. It will have single fills and it'll have

**[17:53]** partial fills with multiple secrets. It'll have everything. So this is definitely the place to start

**[17:59]** to get your footing for the rest of the week. So start there. It's definitely the place to be.

**[18:07]** That is everything for me. Here is a link to hackathon.1-inch.com community. You can either type

**[18:13]** that in your browser or you can use this QR code. It's just a notion page that's kind of like a

**[18:17]** cheat sheet for everything you need to see from for the hackathon. It'll have links to the project

**[18:22]** dice center earlier. It'll have links to all of our documentation pages, all of our protocols,

**[18:27]** how to get API keys if you're using our rest APIs, which me go talked about in the earlier

**[18:32]** presentation on developer portal. So this will be a place to start if you have any questions.

**[18:36]** And then obviously you can talk to us in the discord as well. So that's it for me.

**[18:42]** If there is time for questions, I can answer some questions now.

**[18:46]** Yeah, there is definitely time for questions. If you want to take the next 10 minutes and I'm not

**[18:50]** sure if you can see the chat. Here I can help you if not. But I think people have just kind of been

**[18:58]** in one second. I do see it. Okay. Nice. Okay.

**[19:07]** What do we have?

**[19:13]** People asking about the KYC or no, the claiming API keys.

**[19:18]** Ask us in the discord if the claims not working, somebody should be able to help with that.

**[19:24]** Sometimes it takes a while for us to get those right because it it's gives the KYC to make it easier for

**[19:28]** people and sometimes it takes a little bit of work and sometimes clearing the cookies and your

**[19:31]** browser will also help as well. But asking the discord and we can help you there.

**[19:39]** Okay.

**[19:40]** Okay. So the Dutch auction incentivizes delaying swaps via mutual collusion to get the lowest

**[19:49]** rates. Then it becomes an on-chain gas race between resolvers.

**[19:57]** Yeah, if all of the resolvers were colluding, they could give you worse rates. But we have enough

**[20:04]** resolvers to where I don't think that'd be a problem. That'd be a lot of organization to do.

**[20:10]** But yeah, if every single resolver in the system was on a team acting illistiously,

**[20:15]** it would be a problem. But that would be a lot of organization inclusion. And it would only work once

**[20:22]** and then they'd be banned. And they could do that at least one time. But once we figured out what

**[20:28]** was going on, it wouldn't be something that would be like a longstanding issue.

**[20:33]** Can you compress the time of the auction rate in price increase? Yes. So the auction itself,

**[20:38]** you can control the points entirely yourself. So when you create the auction, you can say,

**[20:44]** this is actually an auction with one static price. You can do an auction where every 10

**[20:48]** seconds it drops, every five seconds it drops. It's based on, I think, timestamps and blocks. But

**[20:53]** you have complete control over that rate of how you want that auction to look, the minimum

**[20:58]** price, all that stuff you can customize when you create it. Which with HTLC, how do you prevent

**[21:08]** griefing resolvers by not releasing the secret? You could definitely grief resolvers by not releasing

**[21:15]** the secret. I think if that becomes a problem, we would come up with some sort of mechanism. But

**[21:22]** I haven't thought about that before. If people really did want to do that, I don't have a good answer

**[21:28]** for you right now. But that's a great question. I never really thought about it from a

**[21:32]** de-doss attack on the resolvers at themselves. You'd have to lock up funds too. But yeah, that's a good

**[21:38]** question. I'll have to think about that if you want to tag me in the Discord. Maybe I can get you a better

**[21:42]** answer. So you've reached the relayer. Interesting.

**[21:47]** Yes, you do have to trust the relayer to share your secret with the rest of the resolverset.

**[21:59]** But the relayer not giving it doesn't really benefit them. I guess if the relayer shared it with

**[22:05]** only a single or that could be a problem. But in the future, so right now, the relayer is a service

**[22:13]** managed by us. The plan is to make the relayer a decentralized service in the future. So yes,

**[22:20]** right now there could be weird problems because the relayer could choose whether or not to share

**[22:25]** or if it wants to share it with a single resolver. But that will be decentralized and improved in the

**[22:30]** future. But yes, that is kind of a weak point right now. That's a good observation.

**[22:35]** The GitHub link for the starter resorter just grab the QR code here. This will link you to it in

**[22:40]** the documentation page. Just go to the Fusion Plus section and you'll find the link to it.

**[22:45]** Again, check that if you can't find it, message us in the GitHub in the Discord.

**[22:53]** If not on the main API, then which one to use. So you're not actually going to be using the

**[22:57]** APIs at all to publish your Fusion Auctions. You'll be doing that directly at the smart contract

**[23:02]** bubble. So when you actually create the escros, you and create the orders. You will be putting

**[23:08]** in the auction data there. So no API calls at all to do the Fusion Plus integration, just contract

**[23:14]** calls and start with that example project to kind of see how it works.

**[23:20]** Okay. Clear and cookies worked. Yes, good. Yeah, always try clear and cookies. I don't know

**[23:25]** why it requires that sometimes. But yeah, always try clear and cookies for the promo codes.

**[23:31]** Oh, I see you found it now.

**[23:33]** Basically, we will be implementing a relayer and resolver for non-EVM chain beside the

**[23:40]** HTLC and non-EVM chain rate. I think I understand your question. Yes, so you will be

**[23:46]** doing your version of the relayer and resolver for communicating between the two chains.

**[23:51]** And you will be doing the HTLC contract implementation on your non-EVM chain. So yes, those are the

**[23:57]** main pieces of the project. A testnet and CLI for the first proof of concept. And then you can build

**[24:03]** up from there. Be it UI. Maybe do something on mainnet, but just get CLI and testnet stuff working first

**[24:08]** and then go from there. Someone asked, what about EVM to non-EVM? That is the bounty.

**[24:15]** It's specifically EVM to non-EVM. So you need to do that cross chain communication. In our

**[24:20]** system, we use our back end relayer service, but this is going to be non-EVM to non-EVM.

**[24:29]** That would be even more for you, but it's not one of our bounty. So the point is to do

**[24:33]** you're kind of like hooking it into our existing set of contracts. So one side does need to be

**[24:37]** Ethereum and it needs to use our official escrow factory as well as our official escrow contracts.

**[24:43]** For the fusion plus side, for the fusion plus bounty, that is correct. You will not be using

**[24:54]** the one in shape. I everything can be done at this mark contract level.

**[25:01]** Okay, I think I got there on these questions. If I give you a bad answer, tell me right now,

**[25:05]** so I can try to give you a better answer. If it was a good answer or an IK answer,

**[25:09]** just come to discord if you have stuff in the future.

**[25:13]** Nice. I have also dropped the link to the live YouTube that will be available to you guys to

**[25:19]** re-watch this workshop. Thank you so much, Tanner, for all of the information. If you guys have

**[25:25]** questions like he said, please go to the discord and it is definitely the best place for those.

